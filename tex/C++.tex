\chapter{C++の基礎}
\label{chap:C++}

この章では、プログラミングやC++の初心者向けに、C++の簡単な解説を行います。第\ref{chap:Install}章の内容や用語がチンプンカンプンだった人は、この章を読んでから先に進むのが良いでしょう。筆者が重要だと思う箇所だけを抜粋して解説しますので、網羅的なC++の解説書も参照することをお勧めします。

ただし、いきなり一般書籍を購入しても当たり外れがあります。特に、C++と銘打っていても、コードの書き方の癖がC言語に近い書物はやめたほうが無難です\footnote{C++の入門書ではありませんが、『Numerical Recipes in C++』は悪書の例です。}。例えば
\begin{lstlisting}[language=c++]
int i;
for (i = 0; i < 100; i++) {
  // some codes...
}
\end{lstlisting}
のように書かれている本よりも
\begin{lstlisting}[language=c++]
for (int i = 0; i < 100; i++) {
  // some codes...
}
\end{lstlisting}
と書かれている本を選んで下さい。また、なるべくクラス（class）の概念が早めに登場する本が良いでしょう。いきなり一般書籍を読み進める前に、まずは本書を眺めてC++言語やプログラミングとは何かを掴んで下さい。プログラミングの専門家を目指すわけではないので、研究室では「使って覚える」を実践するべきです。インターネット上で日本語で閲覧可能なものでは、以下の2つをお勧めします。
\begin{itemize}
\item C++入門\\
\url{http://www.asahi-net.or.jp/~yf8k-kbys/newcpp0.html}
\item ATLAS Japan C++ Course\\
\url{http://www.icepp.s.u-tokyo.ac.jp/~sakamoto/education/atlasj/cplusplus/index.html}
\end{itemize}
この他にも「C++ 入門」などでインターネットを検索すれば大量に出てきますので、好みに合うものを選択してください。

C++が分かればROOTは理解しやすいのですが、ユーザの利便性を考えて、ROOTには独自の仕様が存在します。このような両者の違いについても、この章では説明します。 
\clearpage
\section{Hello World!}
\label{sec:helloworld}
%\begin{NoFloat}
\lstinputlisting[language=c++,float=tb,caption=\texttt{hello\_world.cxx},label=code:hello_world,numbers=left]{src/hello_world.cxx}
%\end{NoFloat}
まず好きなエディタを使って、コード\ref{code:hello_world}を\texttt{hello\_world.cxx}というファイル名で保存して下さい\footnote{Emacs、vi、gedit、TextEditなど何でも構いません。}。次にターミナルから、
\begin{lstlisting}[language=bash]
$ g++ hello_world.cxx
$ ./a.out
\end{lstlisting}
と打ちます\footnote{もし\texttt{g++}が見つからないという内容のエラーが出たら、お使いのコンピュータにGCCもしくはClangをインストールして下さい。「Scientific Linux GCC intall」「Mac Clang intall」などで検索すれば方法は見つかるはずです。Scientific Linux の場合は\texttt{yum}コマンドを使ってGCCを入れることができます。Macの場合はXcodeをApp Storeからダウンロードしてインストールして下さい（無料）。}。
\begin{lstlisting}
Hello World!
\end{lstlisting}
と表示されるはずです。この一連の作業は、
\begin{enumerate}
  \item あなたが\texttt{hello\_world.cxx}というプログラムをエディタで作成し
  \item あなたが\texttt{g++}というコマンド\footnote{GNU Compiler Collection（GCC）に含まれる、C++用のコンパイラです。Macで標準的に使用する\texttt{Clang}では\texttt{clang++}というコマンドが代わりに使えますが、\texttt{g++}コマンドが\texttt{clang++}を実際には呼び出すため、GCCの入っていないMacでも\texttt{g++}コマンドを使うことができます。}に\texttt{hello\_world.cxx}をコンパイルするように指示を出し
  \item \texttt{g++}が\texttt{hello\_world.cxx}をコンピュータが実行できるファイル\texttt{a.out}に変換し
  \item あなたが\texttt{a.out}を実行し
  \item 「Hello World!」という文字列が出力された
\end{enumerate}
ということです。これがプログラミングをするという作業の基本的な流れです。

\texttt{a.out}という変な名前は、\texttt{g++}が作成する実行ファイルのデフォルトの名前です。いくつもプログラムを作成したら、区別できなくなってしまいます。そこで\texttt{g++}に引数をつけて
\begin{lstlisting}[language=bash]
$ g++ hello_world.cxx -o hello_world
$ ./hello_world
\end{lstlisting}
とすれば、好きな名前で実行ファイルを作成してくれます。

さて、コード\ref{code:hello_world}の解説です。まずこのプログラムは、「Hello World!」と呼ばれる、初心者の解説向けによく用いられるものです\footnote{\url{http://ja.wikipedia.org/wiki/Hello_world}などに解説あり。}。このプログラムの主な作業は
\begin{lstlisting}[language=c++]
  printf("Hello World!\n");
\end{lstlisting}
の部分が担っています。\texttt{printf}という関数（function）を使って、「Hello Wolrd!」という文字列を出力させています\footnote{C++では\texttt{std::cout}を紹介するべきですが、ROOTの\texttt{Form}関数やPythonの文字列操作で\texttt{printf}に近い操作が出てくるため、あえて\texttt{printf}を使っています。}。日本語で「関数」と言うと、普通は$y=f(x)$のような数学の関数を想像するでしょう。しかしプログラミングの世界の関数は、必ずしも数字を扱うものではありません。「function」という単語は「機能」という訳語も持ちます。特定の機能をもった命令の集まりが関数です。

\texttt{printf}という名前には、意味があります。「print」という単語と「format」という単語を組み合わせたものです。文字列の書式を整えて出力する関数なので\footnote{この書式の機能は今は使っていません。}、このような名前になっています。関数の名前は、何をする機能を持っているか分かるようになっていなくてはなりません。数学では$y=f(x)$、$y=g(x)$のように抽象的な名前を使いますが、プログラムの中で
\begin{lstlisting}[language=c++]
  g("Hello World!\n");
\end{lstlisting}
と書かれていては、可読性が悪くなります。

さて、「\textbackslash n」という2文字は何でしょうか。これは改行を表す特殊文字です。2文字で1文字だと考えて下さい。試しにコード\ref{code:hello_world}から「\textbackslash n」を取り除いてコンパイルし、実行してみて下さい。改行の有無で出力結果が変わります。

この「Hello World!」という文字列のことを、\texttt{printf}に渡した引数（ひきすう、argument）と言います\footnote{文字列は常に二重引用符で囲む必要があります。二重引用符自体を文字列の中で使用する場合には、\texttt{"\textbackslash ""}のように、バックスラッシュを前方に置きます。}。好きな文字列を渡すことによって、出力結果が変わります。「Hello World!」という文字列しか出力できない関数を作るのではなく、このように引数を変更することで結果を変更できるのが、関数を用意することの最大の利点です。

それではなぜ、この\texttt{printf}という関数を我々は使うことができるのでしょうか。その答えはコード\ref{code:hello_world}の先頭にあります。この行はインクルード（include）文と呼ばれ、他のファイルに既に存在している\texttt{printf}を見えるようにしています\footnote{\texttt{cstdio}は「C」、「standard」、「input/output」の合成語です。C言語の時代に作られた、標準入出力のためのライブラリです。}。したがって、この箇所を
\begin{lstlisting}[language=c++]
// #include <cstdio>
\end{lstlisting}
のようにコメントアウト（comment out）\footnote{先頭が「//」で始まる行は、全てコンパイラに無視されます。}してコンパイルすると、

\begin{lstlisting}[language=bash]
$ g++ -Wall hello_world.cxx
hello_world.cxx: In function ‘int main()’:
hello_world.cxx:5: error: ‘printf’ was not declared in this scope
\end{lstlisting}
とエラーを吐きます。コンパイラは\texttt{printf}が一体なんなのか分からなくなるわけです。

このエラーメッセージを読むと、「In function `int main()'」と書かれています。そうです、この\texttt{main}というのも関数です。この関数のことを\texttt{main}（メイン）関数と呼びます。\texttt{main}関数は、プログラム中に必ず存在しなくてはいけません。\texttt{main}関数の中に書かれた内容が、プログラムの実行時に呼び出される決まりになっているからです。「関数の中」とは\texttt{\{}から\texttt{\}}の中を指しています。この括弧を書くことで、コンパイラは\texttt{main}関数の範囲を理解できるようになります。

\texttt{main}の前にある\texttt{int}（integerのint）は、\texttt{main}関数の返り値（return value）の型（type）を示しています。一般的に、関数は呼び出されると何か値を返します。数学の二次関数$y=f(x)=ax^2+bx+c$であれば、関数$f$に$x$という値を入れると、$ax^2+bx+c$を返しますね。これと同じです。\texttt{main}関数の返り値は、必ず整数（integer）でなくてはいけません。この返り値が0であれば、\texttt{main}関数が正常終了したということを示します。最後に
\begin{lstlisting}
  return 0; 
\end{lstlisting}
と書くことで、確かに\texttt{0}を返す設計になっています。返り値は、\texttt{return}を使って返すことができます。もしこれを\texttt{0}ではなく\texttt{-1}などにすれば、このプログラムは異常終了したとOS側が判断します。

\section{型と関数}
\label{sec:types}
前節の説明では、型、関数、引数、返り値という用語がでてきました。ここでは、もう少し例を挙げて説明します。コード\ref{code:triple}を作成してコンパイルし、実行してみましょう。
%\begin{NoFloat}
\lstinputlisting[language=c++,float=tb,caption=\texttt{triple.cxx},label=code:triple,numbers=left]{src/triple.cxx}
%\end{NoFloat}
15という整数値を持つ変数（variable）\texttt{before}を
\begin{lstlisting}
  int before = 15; 
\end{lstlisting}
のようにして作成しています。数学の変数は、その中身をいつでも整数や無理数や複素数に変更できます。しかしC++の場合は、その変数の種類を後から変更できません。変数\texttt{before}の中身は、いつでも整数値です。先頭の\texttt{int}は、変数\texttt{before}が常に整数値を持つという意味です。これを型（type）と呼びます。つづいて\texttt{= 15}というのが出てきますが、これは「\texttt{before}に15を代入する」という意味です。「\texttt{before}と15は等しい」という意味ではありません。ここは、数学の等号と使用方法が異なります。もしこの直後に
\begin{lstlisting}[language=c++]
before = before * before + 1;
\end{lstlisting}
という文を足すと、\texttt{before}の値が226に変更されます。\texttt{before}の値が二次方程式$x=x^2+1$の解に自動的に変更されたりはしないのです。C++の\texttt{=}は、数学の等号ではなく代入を表します。

関数\texttt{triple}は、引数に与えられた整数値\texttt{v}を、3倍して返す関数です\footnote{C++では、四則演算の記号$+$、$-$、$\times$、$\div$はそれぞれ\texttt{+}、\texttt{-}、\texttt{*}、\texttt{/}で表します。}。整数を3倍してもやはり整数なので、返り値は\texttt{int}になっています。このような関数を作ってしまえば、
\begin{lstlisting}[language=c++]
  int after = triple(before);
\end{lstlisting}
として変数\texttt{after}に関数の返り値を代入することができます。この右辺が呼ばれると、処理は関数\texttt{triple}の行に飛び、
\begin{lstlisting}[language=c++]
  return 3 * v;
\end{lstlisting}
で値が返されて、左辺に代入されます。

そして最後に、変数\texttt{before}、\texttt{after}の中身を
\begin{lstlisting}[language=c++]
  printf("Before: %d\n", before); 
  printf("After : %d\n", after);
\end{lstlisting} 
で出力させています。ここでは、\texttt{printf}の「format」の機能を利用しています。\texttt{\%d}という文字列は、intの変数を文字列に整形して出力するという意味です。\texttt{printf}はこのように、複数の引数（可変長引数）を取ることが可能です。

\texttt{int}以外にも、C++には何種類か型があります。代表的なものが、\texttt{double}（ダブル）です。\texttt{double}型は、\texttt{int}と異なり小数を使うことができます。なぜ\texttt{double}という名前かと言うと、同じように小数を扱う型に\texttt{float}（フロート）があるからです。\texttt{double}は\texttt{float}に比べてメモリを2倍（double）消費します。しかしその分、精度がよくなります\footnote{C++で扱われる小数には精度がつきまといます。例えば$\frac{3}{2}$を小数に直すと、どれだけ小さいほうの桁を見ても0が続きます。しかしコンピュータ上にこのような無限の精度を持つ数を定義すると、メモリが無限大必要になります。これでは実現不可能なため、ある程度の精度を犠牲にします。例えば円周率を\texttt{double}型で扱いたい場合には、有効桁数が15桁しかありません。 $3.14159265358979$までしか精度が保証されないのです。\texttt{float}にした場合はさらに精度が下がり、7桁しか有効桁数がありません。したがって、$1.3\times10^{20}$と$3.4\times10^{-13}$の引き算をそのままC++で実行しても、数学的に正しい数字は得られないので注意が必要です。}。

さて、コード\ref{code:triple}の例では、\texttt{triple}関数は引数と返り値が\texttt{int}型でした。もし\texttt{before}の値が$16.9$だとすれば、\texttt{after}の値は期待通りに動作しません。そこで引数と返り値を\texttt{double}に変更したものを追加したのが、コード\ref{code:triple2}です。同名の\texttt{triple}関数が2つありますが、片方は\texttt{int}用で片方は\texttt{double}用です。このように同じ名前の関数に対して、異なる引数を与えることで処理内容を変更することを、関数のオーバーロード（overload）と言います。コンパイラが引数の違いを適切に見つけ出し、異なる処理をしてくれます。

%\begin{NoFloat}
\lstinputlisting[language=c++,float=tb,caption=\texttt{triple2.cxx},label=code:triple2,numbers=left]{src/triple2.cxx}
%\end{NoFloat}

コード\ref{code:triple2}はコード\ref{code:triple}と違い、\texttt{main}の前に実体を伴わない2つの関数が書かれています。これは関数の前方宣言（forward declaration）と呼ばれるものです。今はなくても構いませんが、ヘッダーファイルを分割して書くようになるときには必須の作業です。このように返り値と引数だけ先に書いておくことで、実際の関数の中身を知らなくても（関数が後で定義されていても）、コンパイラは\texttt{main}関数の中で\texttt{triple}が出てきても問題なく処理を続行できるようになります。プログラムの可読性を高めるという意味もあります。\texttt{main}関数の後に、実際の\texttt{triple}関数の中身が記述されています。これを、関数の定義（definition）と呼びます。

新たな\texttt{printf}の使い方として、
\begin{lstlisting}[language=c++]
  printf("Before: %f\n", before_d); 
  printf("After : %f\n", after_d); 
\end{lstlisting} 
のように\texttt{\%d}ではなく\texttt{\%f}というのが登場しています。これは、\texttt{double}型を整形するための特殊な文字列です\footnote{他にもフォーマットの種類がいくつか存在しますので、「\texttt{printf}」で検索してみてください。}。

なぜこれらの例で、2倍にする関数ではなく3倍にするものを選んだかというと、\texttt{double}という単語がC++の予約語（reserved word）だからです。C++が既に確保している名前を、ユーザが勝手に使うことはできません。\texttt{printf}のように一般的に使われる関数名も、使わないことが推奨されます。もしあなたが「f」という文字を出力する関数を\texttt{printf}という名前で作成したら、他の人は混乱するでしょう。

\section{\texttt{if}文と関係演算子}

ここまでで、関数の簡単な使い方が分かりました。しかし、四則演算程度しかまだやり方をしりません。2つの数字の大小を比べるにはどうしたら良いでしょうか。この節では、関係演算子と\texttt{if}文の使い方を説明します。

%\begin{NoFloat}
\lstinputlisting[language=c++,float=tb,caption=\texttt{minmax.cxx},label=code:minmax,numbers=left]{src/minmax.cxx}
%\end{NoFloat}

コード\ref{code:minmax}には、新しい関数\texttt{min}と\texttt{max}を作りました。初めて、
\begin{lstlisting}[language=c++]
  if (v1 < v2) {
    ret = v1;
  } else {
    ret = v2;
  }
\end{lstlisting}
という\texttt{if}文が出てきます。これを日本語訳すると、「もし（\texttt{if}）\texttt{v1}が\texttt{v2}よりも小さければ、\texttt{ret}に\texttt{v1}を代入しなさい。そうでなければ（\texttt{else}）\texttt{v2}を代入しなさい」となります。\texttt{<}は関係演算子や比較演算子（relational operator、comparison operator）と呼ばれるものです。もし左辺が小さければ\texttt{true}を、そうでなければ\texttt{false}を返します。つまり
\begin{lstlisting}[language=c++]
bool a = 10 < 20;
bool b = 10 > 20;
\end{lstlisting}
とすれば、\texttt{a}と\texttt{b}の値はそれぞれ\texttt{true}と\texttt{false}になります。\texttt{if}文の中身（\texttt{\{}と\texttt{\}}で囲まれた部分）は、条件式が\texttt{true}もしくは真（非ゼロの値）のときだけ実行されます。\texttt{v1}が小さいときは返り値として\texttt{v1}を返して\texttt{min}関数は終了します。

\texttt{<}があれば、当然\texttt{>}も存在します。同様に、 \texttt{<=}と\texttt{>=}も存在します。それぞれ見たままの通りで、$<$、$>$、$\le$、$\ge$を表します。一見その機能が分かりにくい、\texttt{==}と\texttt{!=}も存在します。前者は両辺が等しいときに\texttt{true}を返し、後者は等しくないときに\texttt{true}を返します\footnote{C文字列の比較は、比較演算子ではできません。これは\ref{sec:pointers}節で説明します。}。

\texttt{>}を使って、\texttt{max}関数も定義しました。しかし今度は
\begin{lstlisting}[language=c++]
  return v1 > v2 ? v1 : v2;
\end{lstlisting}
という、わけの分からない記号が並んでいます。これは三項演算子もしくは条件演算子と呼ばれる記法で、最初は分かりにくいですが慣れると\texttt{min}関数の中身よりも分かりやすいはずです。\texttt{?}と\texttt{:}で、これは3つの部分に分かれています。日本語に訳すと、「もし\texttt{v1}が\texttt{v2}よりも大きければ \texttt{?} \texttt{v1}を返す \texttt{:} そうでなければ\texttt{v2}を返す」となっています。

\section{\texttt{for}文}

なぜコンピュータを使ってプログラミングをするのかと言えば、人間には手に負えない、複雑な計算をする必要があるからです。特に同じ作業を繰り返す場合には、コンピュータを利用すると劇的に処理速度が向上します。そこで登場するのが\texttt{for}（フォー）文です。\texttt{for}文の使い方を学ぶために、非常に初等的な手段で円周率$\pi$を計算してみましょう。

%\begin{NoFloat}
\lstinputlisting[language=c++,float=tb,caption=\texttt{pi.cxx},label=code:pi,numbers=left]{src/pi.cxx}
%\end{NoFloat}

コード\ref{code:pi}では、$-1<x<1$、$-1<y<1$の範囲に等間隔で並ぶ、$4n^2$個の格子点の場所を計算しています。これらの点のうち、半径1の単位円の内部に存在する個数を数え上げると、$\simeq\pi n^2$個になるはずです\footnote{$n\rightarrow\infty$の場合、本当に$\pi$に収束するかは真面目に考えていません。}。

以下の、\texttt{main}の中身が\texttt{for}文です。
\begin{lstlisting}[language=c++]
  for (int i = 1; i <= 100; ++i) {
    printf("n = %d: pi = %lf\n", i, pi(i));
  } // i
\end{lstlisting}
最初の行を日本語にすると、「\texttt{i}が1の状態から開始し、100以下の間だけ以下の作業を繰り返しなさい。ただし、1度繰り返した直後に、\texttt{i}は1ずつ増やせ」となります\footnote{\texttt{i}は「index」の「i」です。\texttt{for}文は入れ子にすることができ、そのような場合は\texttt{j}や\texttt{k}をその後の添え字として使います。ただし、小文字のL \texttt{l}を\texttt{k}の後に使うのは避けて下さい。数字の\texttt{1}と視覚的に区別が難しいためです。}。つまり、\texttt{i}が1から100まで変化します。\texttt{i++}という表現は始めて出てきました。これは
\begin{lstlisting}[language=c++]
i = i + 1;
\end{lstlisting}
や
\begin{lstlisting}[language=c++]
i += 1;
\end{lstlisting}
と同じ意味を持ちます\footnote{なぜ複数の書き方が可能かというと、「1だけ増加させた」ということをより明示的にするためです。}。これをインクリメント演算子（increment operator）と呼びます。

\texttt{i++}（後置演算、pre-increment）の代わりに\texttt{++i}（前置演算、post-increment）という書き方を次のようにする場合もあります。単純なfor文では動作結果に違いはでませんが\footnote{\texttt{y = ++x;}や\texttt{y = x++;}のように、代入を伴う場合は挙動が異なるので注意してください。前者は\texttt{x += 1; y = x;}、後者は\texttt{y = x; x += 1;}という意味になります。}、コンパイラの生成する実行ファイルは若干高速になることがあるかもしれません。本書では\texttt{++i}を使用します。
\begin{lstlisting}[language=c++]
  for (int i = 1; i <= 100; ++i) {
    printf("n = %d: pi = %lf\n", i, pi(i));
  } // i
\end{lstlisting}

\texttt{for}文の文法さえ分かれば、\texttt{pi}関数の中で使われている\texttt{for}文も理解できるでしょう。関係演算子が\texttt{<}の場合と\texttt{<=}の場合で繰り返し回数が変わることに注意して読んで下さい。

ここまでで、あなたは四則演算を使った膨大な計算をできるようになりました。例えば
\begin{equation}
\sin(x) = x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots
\end{equation}
のような手では面倒な計算も（\texttt{double}の精度で）可能になります。試してみて下さい。

\clearpage

\section{クラス}
\texttt{int}型と\texttt{double}型の使い方は覚えました。しかし、$(x, y, z)$や$(p_x, p_y, p_z, E)$のようなベクトルを考えた場合、変数を3つや4つも自分で管理するのは面倒です。2つのベクトルの足し算をして新しいベクトルを作るときに、
\begin{lstlisting}[language=c++]
double x1 = 1.5, y1 = 2.3, z1 = -0.4;
double x2 = -3.1, y2 = 5.6, z2 = 1.9;
double x3 = x1 + x2, y3 = y1 + y2, z3 = z1 + z2;
\end{lstlisting}
と書くと見づらいです。可能ならば
\begin{lstlisting}[language=c++]
Vector3D v1(1.5, 2.3, -0.4);
Vector3D v2(-3.1, 5.6, 1.9);
Vector3D v3 = v1 + v2;
\end{lstlisting}
のように書けたほうがすっきりします。これがクラス（class）の発想です。自分で好きな型を作ることが可能になります。

それでは、早速クラスを自分で作ってみましょう。ソースコードを眺めながら、クラスとは何かを理解してください。コード\ref{code:Vector3D_h}、\ref{code:Vector3D_cxx}、\ref{code:Vector3D_main_cxx}は、3次元ベクトルを扱うためのクラスの作成例です。\texttt{virtual}という予約語が出てきますが、今はこれを無視して読み飛ばしてください。\ref{subsec:virtual}節で説明します。

\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{Vector3D.h},label=code:Vector3D_h,numbers=left]{src/Vector3D.h}
\end{NoFloat}
\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{Vector3D.cxx},label=code:Vector3D_cxx,numbers=left]{src/Vector3D.cxx}
\end{NoFloat}
\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{Vector3D\_main.cxx},label=code:Vector3D_main_cxx,numbers=left]{src/Vector3D_main.cxx}
\end{NoFloat}

3つのファイルに分割したのは、可読性と可搬性\footnote{他のプログラムでも使い回しが効くという意味です。}を高めるためです。もし全てを1つのファイルに書いてしまうと、せっかく作った\texttt{Vector3D}というクラスを他のプログラムで使うのが面倒になります。クラスの記述と\texttt{main}文を分けておくことで、他の\texttt{main}文を書いたときにも、クラスの記述を何度も繰り返す必要がなくなります。\texttt{Vector3D.h}と\texttt{Vector3D.cxx}は、それぞれヘッダーファイル（header file）、ソースファイル（source file）と呼ばれます\footnote{C++のヘッダーとソースの拡張子には、いくつかの流儀があります。例えばROOTでは、\texttt{.h}と\texttt{.cxx}という拡張子をそれぞれに使っています（ただし、スクリプトファイルには区別のために\texttt{.C}を採用しています）。またGeant4では、\texttt{.hh}と\texttt{.cc}を使っています。C++のソースコードの拡張子には、他にも\texttt{.C}、\texttt{.c++}、\texttt{.cpp}なども世の中では使われています。どの拡張子を使うかは本質的な問題ではありません。本書では、ROOTの流儀に合わせて\texttt{.h}と\texttt{.cxx}を採用します。}。まずは新しく作ったこのプログラムをコンパイルして、コンパイル済みの実行ファイルを走らせてみましょう。
\begin{lstlisting}[language=bash]
$ g++ -c Vector3D.cxx
$ g++ -c Vector3D_main.cxx
$ g++ Vector3D.o Vector3D_main.o -o Vector3D
$ ./Vector3D
\end{lstlisting}
1行目と2行目では\texttt{-c}オプションをつけて、\texttt{Vector3D.cxx}と\texttt{Vector3D\_main.cxx}をコンパイルだけしています。これらはコンパイル後に拡張子が\texttt{.o}のオブジェクトファイル（object file）に変換されます。「コンパイルだけ」というのは、実行ファイルを作成しないということです。\texttt{Vector3D.cxx}には\texttt{main}文が存在せず、また\texttt{Vector3D\_main.cxx}にはクラスの中身が書かれていないので、そのままでは実行ファイルが作成できません。3行目で2つのオブジェクトファイルを結合し、\texttt{Vector3D}という実行ファイルが作成されます。今のコードでは必要性をあまり感じませんが、膨大な量のソースコードをコンパイルするときには、このような分割コンパイルは必須です。修正個所だけコンパイルし直すことで、時間を節約できるからです。

\subsection{クラス宣言}
それでは、\texttt{Vector3D}クラスの説明に移ります。コード\ref{code:Vector3D_h}では、クラス\texttt{Vector3D}の宣言（declaration）を行っています。「宣言」とは、クラスの基本仕様を書く作業のことです。C++では\texttt{int}や\texttt{double}のような基本的な型しか持っていませんので、あなたが新しいクラスを作るときには、それがどんなものであるかを教えてやる必要があります。

クラスの宣言に最低限必要な部分は、次の箇所だけです。他の箇所は、そのクラスがどんな性質を持つかを記述するためのものですので、以下の記述だけでは何の役にも立たないクラスができあがります。
\begin{lstlisting}[language=c++]
#ifndef VECTOR_3D
#define VECTOR_3D

class Vector3D {};

#endif // VECTOR_3D
\end{lstlisting}
最後のセミコロンを忘れやすいので注意してください。

\texttt{\#}で始まる行は、おまじないです。色々なファイルから\texttt{Vector3D.h}を何度もインクルードすると、あたかも\texttt{Vectr3D}クラスが何度も宣言されたように見え、コンパイルエラーが起きます。これを防ぐために、\texttt{VECTOR\_3D}と文字列をここでは定義しています。\texttt{\#ifndef VECTOR\_3D}は、「もし\texttt{VECTOR\_3D}が定義されていなかったら（IF Not DEFine）」という意味です。\texttt{VECTOR\_3D}が定義されていないときだけ、\texttt{\#endif}までの内容が実行されます。つまり、\texttt{VECTOR\_3D}を\texttt{\#define}し、クラス宣言を行います。この仕組みを「インクルードガード（inclue guard）」と呼びます\footnote{\texttt{VECTOR\_3D}という文字列は、\texttt{VECTOR3D}でも\texttt{HOGE}でも、別に好きなもので構いません。ただし、コードを読む人が分かりやすいもので、なおかつ、他のプログラムで使われていなさそうな名前にしてください。\texttt{\#endif}の後のコメント行は無くても構いませんが、長いコードの場合は、何に対応する\texttt{\#endif}なのかを分かりやすくするため、このような書き方をすることがあります。}。

\subsection{メンバ変数}
\label{subsec:members}
クラスが保持する情報は、メンバ変数（member variable）に格納されます。コード\ref{code:Vector3D_h}では、\texttt{fX}、\texttt{fY}、\texttt{fZ}\footnote{変数名の最初のfは、メンバ変数と他の変数の区別をしやすくするためのものです。これはROOTで使われる変数名の命名規則ですが、他にも\texttt{mX}や\texttt{m\_x}と書いたり（memberのm）、単に\texttt{x}とする文化もあります。}という3つのメンバ変数が存在します。今はメンバ変数に\texttt{double}型しか使っていませんが、\texttt{int}を使ったり、他のクラスを使うことも可能です。今回は3次元ベクタを記述するためのクラスの例ですので、XYZ座標をこれらのメンバ変数が\texttt{double}型で保持します。これらメンバ変数の直前に書かれている\texttt{private:}は、「次の変数はプライベート変数だよ」という目印です。個人情報のようなもので、特別に公開する手段を持たない限り、本人以外は外から知ることができません。

\subsection{コンストラクタ}
\texttt{Vector3D()}、\texttt{Vector3D(double x, double y, double z)}、\texttt{Vector3D(const Vector3D\& other)}の3つの関数は、コンストラクタ（constructor）と呼ばれる特殊な関数です。クラス名と同じ関数名になっています。これらの関数がいつ使われるかというと、クラスを実際に使用し始める瞬間です。コード\ref{code:Vector3D_main_cxx}では\texttt{v0}という変数\footnote{インスタンス（instance）とも呼びます。}を
\begin{lstlisting}[language=c++]
  Vector3D v0;
\end{lstlisting}
のようにして作成しています。このように作成した変数では、\texttt{Vector3D()}のほうのコンストラクタが呼び出されます。このような引数を持たないコンストラクタを、デフォルトコンストラクタ（default constructor）と呼びます。また
\begin{lstlisting}[language=c++]
  Vector3D v1(1.5, 2.3, -0.4);
\end{lstlisting}
のように引数をつけて変数を作成した場合は、\texttt{Vector3D(double x, double y, double z)}のほうが呼び出されます。それぞれのコンストラクタの実体はコード\ref{code:Vector3D_cxx}に書かれており、それぞれのコンストラクタで\texttt{fX}、\texttt{fY}、\texttt{fZ}全てにゼロを代入するか、与えられた引数を代入していることが分かります。コンストラクタはクラスが使われる瞬間に呼び出されるため、一般的にはメンバ変数などの初期化に使われます。\texttt{Vector3D}では、$(x, y, z)$をデフォルトコンストラクタで$(0, 0, 0)$に設定するか、与えられた3変数を代入することによって、初期化しています。

もしあなたがどちらのコンストラクタも作らないと、コンパイラは自動的にデフォルトコンストラクタを作るので注意が必要です。しかし引数を持つコンストラクタを1つでも作れば、コンパイラはデフォルトコンストラクタを作成しません。そのため、今回の例ではデフォルトコンストラクタと引数を持つコンストラクタを両方作成しています\footnote{このようにデフォルトコンストラクタを作らなくても、\texttt{Vector3D v0(0, 0, 0)}と書けば全く同じ結果が得られます。しかし後々複雑なプログラムを書くようになると、どんな値を詰めるか考えないで、ひとまず変数を用意する場面が出てきます。このようなときにデフォルトコンストラクタは必要になります。}。コンパイラにデフォルトコンストラクタを自動生成させた場合、メンバ変数はその型やクラスの初期値を持ちます。この例では、\texttt{fX}、\texttt{fY}、\texttt{fZ}はどれも\texttt{double}型なので、初期値はゼロになります。

デフォルトコンストラクタの使用方法は、以下の2通りの書き方がありますが、機能としては全く同一です。
\begin{lstlisting}[language=c++]
Vector3D v0;
Vector3D v0();
\end{lstlisting}
コンストラクタも関数的に振る舞うため本来は\texttt{()}の部分が必要なのですが、引数を持たないデフォルトコンストラクタでは省略することができます。

\ref{sec:types}節で説明したように、一般的な関数は返り値を持ちます。しかしコンストラクタは特殊な関数であり、返り値は持ちません。返り値を持たない関数には通常\texttt{void}を付ける必要がありますが、コンストラクタは返り値を持たないのが分かっているので、\texttt{void}を書く必要はありません。

これらコンストラクタと別に
\begin{lstlisting}[language=c++]
  Vector3D(const Vector3D& other);
\end{lstlisting}
として宣言されているコンストラクタをコピーコンストラクタ（copy constructor）と呼びます。既に存在しているインスタンスから、全く同じ内容のインスタンスを作成するときに使用します。コード\ref{code:Vector3D_main_cxx}の例では、
\begin{lstlisting}[language=c++]
  Vector3D v4(v1 - v2);
\end{lstlisting}
が該当します。\texttt{v1 - v2}の部分や\texttt{\&}の意味は節\ref{subsec:operator_overload}で説明しますが、ここでは引数に\texttt{Vector3D}が与えられ、その中身が\texttt{v4}にそのままコピーされます。

この例ではコピーコンストラクタを本当は自作する必要はありません。なぜなら、コピーコンストラクタを明示的に作成しなかった場合、これもコンパイラによって自動生成されるからです。コード\ref{code:Vector3D_cxx}、\ref{code:Vector3D_h}では、わざわざ自分で書きましたが、その必要はありません。特に、メンバ変数の中身をそのままコピーするだけのコピーコンストラクタならば、自分でコードを書かずにコンパイラに任せてしまいましょう。人間がやるとバグの元になります。

\subsection{メンバ関数}

プライベートなメンバ変数とコンストラクタを持つだけでは、そのクラスが持つ情報にユーザはアクセスすることができません。そこで、\ref{subsec:members}節に書いたように、「特別に公開する手段」が必要となります。コード\ref{code:Vector3D_h}に書かれた\texttt{X()}、\texttt{Y()}、\texttt{Z()}の3つの関数は、メンバ変数\texttt{fX}などを取り出すための関数で、その中身は短く、単純にメンバ変数の値を返しています。\texttt{const}修飾子というものが出てきていますが、これはクラスの持つメンバ変数の値を変更しないという目印です。つけなくてもこの例では大差ありませんが、おまじないです。\texttt{X()}のような短い関数は、可読性の落ちない限り、このようにヘッダーの中に書いてしまうことが頻繁に行われます。ヘッダーの中に書き込むことで、処理速度の向上が見込まれるためです。これを関数のインライン化と言います。また、\texttt{inline}という予約語を使うことでインライン関数をクラス定義の外側に書くことができます。コード\ref{code:Vector3D_h}では、\texttt{Vector3D::Z()}だけクラス定義の外側でインライン化させています。

メンバ変数の情報を取り出す以外にも、様々な動作をメンバ関数にさせることが可能です。コード\ref{code:Vector3D_h}ではさらに、\texttt{Print()}というメンバ関数を追加しています。実行ファイル\texttt{Vector3D}を走らせれば分かるように、これは3次元ベクタの中身を表示するための関数です。この関数の実体は、やはりコード\ref{code:Vector3D_cxx}に書かれています。

コンストラクタやメンバ関数をソースファイルに記述するとき、
\begin{lstlisting}[language=c++]
void Vector3D::Print() const
\end{lstlisting}
のような記述方法をします。\texttt{Print()}という関数がどのクラスのメンバ関数なのかをはっきりさせるため、\texttt{Vector3D::}という所有格を明示する記述が必要になります。この\texttt{Print()}というメンバ関数ではメンバ変数を表示するだけなので、やはり\texttt{const}を付けておきましょう。

コード\ref{code:Vector3D_cxx}で定義した\texttt{Print()}や\texttt{X()}という\texttt{Vector3D}クラスのメンバ関数は、
\begin{lstlisting}[language=c++]
Vector3D v(1., 2., 3.);
double x = v.X();
v.Print();
\end{lstlisting}
のようにして、変数\texttt{v}の後に\texttt{.}と関数名を繋げることにより、呼び出すことが可能です。この\texttt{.}は、日本語の「の」だと思えば良いでしょう。上記の例では、「変数\texttt{v}の\texttt{X()}を呼び出す」「変数\texttt{v}の\texttt{Print()}を呼び出す」のように理解してください。

\subsection{演算子オーバーロード}
\label{subsec:operator_overload}
せっかく3次元ベクタを扱うクラスを作っても、数学的な演算ができなければ役に立ちません。そこで、C++には演算子オーバーロード（operator overloading）という機能があります。ベクタの加減や、内積といった演算が直感的に行えれば、ややこしいコードを何度も書く必要はなくなります。コード\ref{code:Vector3D_main_cxx}では、ベクタの加減算と内積を行っています。コンピュータには\texttt{Vector3D}同士の足し算とは一体何をするべき作業なのか分かりません。そのため、\texttt{+}や\texttt{*}演算子を使ったときにどのような処理を実行するべきかは、ユーザが決定してやる必要があります。これが演算子オーバーロードです。

コード\ref{code:Vector3D_h}と\ref{code:Vector3D_cxx}には、\texttt{operator}という文字の入った関数が出てきます。\ref{code:Vector3D_cxx}に定義された、\texttt{Vector3D}同士の足し算の定義を見てみましょう。
\begin{lstlisting}[language=c++]
Vector3D Vector3D::operator+(const Vector3D &vec) {
  return Vector3D(fX + vec.X(), fY + vec.Y(), fZ + vec.Z());
}
\end{lstlisting}

3次元ベクタ同士を足せば、その結果は当然3次元ベクタになります。したがって、\texttt{operator+}の返り値は当然\texttt{Vector3D}になります。また、\texttt{operator+}は関数の形をしていますが、実際に使うときは
\begin{lstlisting}[language=c++]
Vetor3D v3 = v1 + v2;
\end{lstlisting}
のように使います。
\begin{lstlisting}[language=c++]
Vetor3D v3 = v1.operator+(v2);
\end{lstlisting}
のようには使わないので注意が必要です。

さて、\texttt{operator+}の引数の記述はこれまで見たことがない形式です。まず\texttt{const}修飾子がここでも出てきています。これは、引数\texttt{vec}の中身を一切変更しませんという宣言です。\texttt{v1}と\texttt{v2}の足し算をしている最中に、\texttt{v2}の中身が変わったりしたら困るからです。また、引数の型が\texttt{Vector3D}なのは当然です。\texttt{Vector3D}同士の足し算を定義しているからです。\texttt{\&}という初めて使う記号がその直後についています。これは、参照渡し（call by reference）と呼ばれる方法です。\texttt{\&}がない場合、C++では引数のコピーをその都度作成し、その関数を実行し終えると自動的にそのコピーが破棄されます。今はたった3つのメンバ変数しか持っていませんが、メンバ変数に長い文字列や画像データを持つクラスでは、いちいちコピーを作成しているとコンピュータ資源の無駄になります。そこで、\texttt{\&}をつけた場合には、その関数は引数の本体を参照するようになります。

さて、\texttt{+}、\texttt{-}、\texttt{*}に加えて、代入演算子\texttt{=}がコード\ref{code:Vector3D_main_cxx}では使われています。これは他の演算子と異なり、返り値が\texttt{Vector3D}ではなく\texttt{Vector3D\&}です。また\texttt{this}という予約語が使われています\footnote{\ref{sec:pointers}を読んでから、再度この段落を読んでみてください。}。\texttt{this}は、インスタンスが自分自身を指し示すポインタです。したがって、
\begin{lstlisting}[language=c++]
  if (this != &other) { 
    fX = other.fX; 
    fY = other.fY; 
    fZ = other.fZ; 
  } 
\end{lstlisting}
の部分は、
\begin{lstlisting}[language=c++]
v1 = v1;
\end{lstlisting}
のような、自分自身への代入を無駄に実行したときに読み飛ばされるようになっています。上記のような代入がされただけでは、返り値を持つ必要がありません。\texttt{if}文の中の代入操作さえ終われば、左辺の\texttt{v1}が何を返そうが、何も起きないからです。しかし、C++では
\begin{lstlisting}[language=c++]
v1 = v2 = v3;
\end{lstlisting}
のような書き方もできます。この場合には、\texttt{v2}に\texttt{v3}が代入された後、\texttt{v2}が自分自身への参照を返してくれないと、\texttt{v1}への代入が行えません。そのため、\texttt{operator=}の返り値は\texttt{Vector3D\&}でなくてはならないのです。

代入演算子はコピーコンストラクタと同様、明示的に書かれていなければコンパイラが自動生成します。デフォルトの代入演算子では、メンバ変数の内容を全く同一にコピーしたものを代入先に渡します。この例ではわざと自分で書きましたが、コピーコンストラクタと同様、コンパイラ任せにできる場合は書く必要はありません。

\subsection{継承}

クラスの面白い機能に継承（inheritance）があります。あるクラスの機能をそのまま受け継いだ（継承した）、他のクラスを作る機能です。ここでは、ローレンツベクタを例に考えることにします。ローレンツベクタは、空間情報$(x, y, z)$に加えて、時間という新たな変数$t$が追加されます。したがって、先ほど作成した\texttt{Vector3D}を継承した、変数$t$を持つクラスを作れば、色々なコードを再利用できます。コード\ref{code:LorentzVector_h}、\ref{code:LorentzVector_cxx}、\ref{code:LorentzVector_main_cxx}に、\texttt{Vector3D}を継承した新しいクラス\texttt{LorentzVector}の例を示します。前と同様に、
\begin{lstlisting}[language=bash]
$ g++ -c Vector3D.cxx
$ g++ -c LorentzVector.cxx
$ g++ -c LorentzVector_main.cxx
$ g++ LorentzVector.o Vector3D.o LorentzVector_main.o -o LorentzVector
$ ./LorentzVector
\end{lstlisting}
とすれば実行可能です。\texttt{Vector3D.cxx}のコンパイルも必要なことに注意してください。

\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{LorentzVector.h},label=code:LorentzVector_h,numbers=left]{src/LorentzVector.h}
\end{NoFloat}
\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{LorentzVector.cxx},label=code:LorentzVector_cxx,numbers=left]{src/LorentzVector.cxx}
\end{NoFloat}
\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{LorentzVector\_main.cxx},label=code:LorentzVector_main_cxx,numbers=left]{src/LorentzVector_main.cxx}
\end{NoFloat}

コード\ref{code:LorentzVector_h}では\texttt{Vector3D}のときと同様に、\texttt{LorentzVector}クラスの宣言を行っています。前と違うところは、\texttt{Vector3D}を継承している点です。
\begin{lstlisting}[language=c++]
class LorentzVector : public Vector3D
\end{lstlisting}
と書くことで、\texttt{Vector3D}を継承したクラスになります。\texttt{public}はおまじないです。継承される側のクラスを基底クラス（base class）、親クラス、スーパークラス（super class）と呼び、また継承する側を派生クラス（derived class）、子クラス、サブクラス（sub class）と呼びます。

\texttt{LorentzVector}クラスには、新たに\texttt{fT}というメンバ変数が追加されています。\texttt{fX}などは、一切宣言されていません。他の変数は既に\texttt{Vector3D}が持っており、その変数ごと\texttt{LorentzVector}は継承しているので、宣言し直す必要がないからです。

\texttt{fT}を追加したのであれば、これを取り出すための関数も必要になります。これも同様に、\texttt{X()}などは既に\texttt{Vector3D}から継承済みなので、\texttt{T()}だけ追加すれば良いことになります。他のメンバ変数は\texttt{private}として\texttt{Vector3D}で宣言されていました。そのため、\texttt{LorentzVector}のメンバ関数からは、\texttt{fX}などは\texttt{X()}などを通じないと取り出せなくなっています。そのため\texttt{LorentzVector::operator+}などの定義では、\texttt{fX}を直接触らずに\texttt{X()}を使っています。

コンストラクタは、新たに書き直しが必要です。コンストラクタは\texttt{fX}、\texttt{fY}、\texttt{fZ}、\texttt{fT}の全てを初期化する必要があるので、\texttt{Vector3D}のコンストラクタをそのまま使うことはできません。コード\ref{code:LorentzVector_cxx}では、\texttt{fT}の初期化作業が、\texttt{Vector3D}のコンストラクタに比べて増えています。ここで注目して欲しいのが、コード\ref{code:LorentzVector_cxx}のコンストラクタのうち、
\begin{lstlisting}[language=c++]
LorentzVector::LorentzVector(const LorentzVector &other) : Vector3D(other) {
  fT = other.fT;
}
\end{lstlisting}
や
\begin{lstlisting}[language=c++]
LorentzVector::LorentzVector(double x, double y, double z, double t)
    : Vector3D(x, y, z)
\end{lstlisting}
で使われている、単独のコロン（:）の後ろの部分です。このような書き方をすると、\texttt{LorentzVector}のうち\texttt{Vector3D}に由来する部分を\texttt{Vector3D}のコンストラクタを使って初期化することができます。いちいち、\texttt{fX}などへの代入作業を書き直す必要がなくなります。

また、\texttt{Print()}や演算子も\texttt{fT}に関する記述を追加する必要があるので、新たに書き直しています。\texttt{Print()}のように、親クラスの持つメンバ関数と外見上全く同じメンバ関数を作成することを、関数のオーバーライド（override）と言います。\texttt{fX}、\texttt{fY}、\texttt{fZ}は\texttt{private}として宣言しました。そのため、\texttt{LorentzVector}からは\texttt{X()}などの関数を使わないとアクセスできなくなっていることに注意してください。

\section{基本型と精度}
\label{sec:primitive}

ここまでで\texttt{int}や\texttt{double}という型が出てきました。これらを総称して基本型（プリミティブ型、primitive type）と呼び、他にも様々な種類があります。

数学の世界でも数字には様々な種類があります。整数、自然数、少数、超越数、複素数などです。例えば10とか123のような整数を紙に記入するとき、我々はその精度をあまり気にすることなく精確に書くことができます。しかし例えば$1/3=0.333\ldots$のような循環小数を分数を使わずに精確に書けと言われると、いくら桁数を増やしてもいつまでも精確な値にはなりません。またあまりに大きな桁の整数を精確に書くことも困難です。

これと同様に、計算機の持つメモリというのは資源が限られています。そこで基本型といういくつかの型を用意することで、多くの計算はその制限の範囲内で行います。そしてその数値は、計算機の内部で二進数として表現されており、何ビットのメモリを使用するかによって表~\ref{table:primitive}のように型が分けられています。

\begin{landscape}
\begin{table}
  \centering
  \caption{C++で用意されている主要な基本型。複数の型指定子が存在する場合、どれを使っても良い。一般的に使われる表記を太字で示してある。}
  \label{table:primitive}
  \footnotesize
\begin{tabular}{|l|l|l|l|l|l|l|}
  \hline
型指定子 & ROOT での表現 & C++標準のビット幅 & 64 bit Windows & 64~bit macOS/Linux & 注意 & 扱える範囲 \\
\hline
\textbf{\texttt{short}}             & \multirow{4}{*}{\texttt{Short\_t}}   & \multirow{6}{*}{少なくとも16} & \multirow{6}{*}{16} & \multirow{6}{*}{16} & \multirow{6}{*}{}                                 & \multirow{4}{*}{$-32768$〜$+32767$}                                               \\ \cline{1-1}
\texttt{short int}                  &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed short}               &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed short int}           &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-3} \cline{7-7} 
\textbf{\texttt{unsigned short}}    & \multirow{2}{*}{\texttt{UShort\_t}}  &                          &                     &                     &                                                   & \multirow{2}{*}{$0$〜$65535$}                                                    \\ \cline{1-1}
\texttt{unsigned short int}         &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \hline
\textbf{\texttt{int}}               & \multirow{3}{*}{\texttt{Int\_t}}     & \multirow{5}{*}{少なくとも16} & \multirow{5}{*}{32} & \multirow{5}{*}{32} & \multirow{5}{*}{}                                 & \multirow{3}{*}{\begin{tabular}{c}$-2,147,483,648$\\〜$+2,147,483,647$\end{tabular}}                               \\ \cline{1-1}
\texttt{signed}                     &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed int}                 &                   &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-3} \cline{7-7} 
\texttt{unsigned}                   & \multirow{2}{*}{\texttt{Uint\_t}}    &                          &                     &                     &                                                   & \multirow{2}{*}{$0$〜$+4,294,967,295$}                                            \\ \cline{1-1}
\textbf{\texttt{unsigned int}}      &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \hline
\textbf{\texttt{long}}              & \multirow{4}{*}{\texttt{Long\_t}}    & \multirow{6}{*}{少なくとも32} & \multirow{6}{*}{32} & \multirow{6}{*}{64} & \multirow{6}{*}{環境依存（ROOT でも）}                & \multirow{4}{*}{}                                                                                                           \\ \cline{1-1}
\texttt{long int}                   &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed long}                &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed long int}            &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-3} \cline{7-7} 
\textbf{\texttt{unsigned long}}     & \multirow{2}{*}{\texttt{ULong\_t}}   &                          &                     &                     &                                                   & \multirow{2}{*}{}                                                                                                           \\ \cline{1-1}
\texttt{unsigned long int}          &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \hline
\textbf{\texttt{long long}}         & \multirow{4}{*}{\texttt{Long64\_t}}  & \multirow{6}{*}{少なくとも64} & \multirow{6}{*}{64} & \multirow{6}{*}{64} & \multirow{6}{*}{C++11以降}                          & \multirow{4}{*}{\begin{tabular}{c}$-9,223,372,036,854,775,808$\\〜$+9,223,372,036,854,775,807$\end{tabular}} \\ \cline{1-1}
\texttt{long long int}              &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed long long}           &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-1}
\texttt{signed long long int}       &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \cline{1-3} \cline{7-7} 
\textbf{\texttt{unsigned long long}}& \multirow{2}{*}{\texttt{ULong64\_t}} &                          &                     &                     &                                                   & \multirow{2}{*}{$0$〜$18,446,744,073,709,551,615$}                               \\ \cline{1-1}
\texttt{unsigned long long int}     &                             &                          &                     &                     &                                                   &                                                                                                                             \\ \hline
\textbf{\texttt{signed char}}       &                             &                        & 8                   & 8                   &                                                   & $-128$〜$127$                                                                    \\ \hline
\textbf{\texttt{unsigned char}}     & \texttt{UChar\_t}                    &                         & 8                   & 8                   &                                                   & $0$〜$255$                                                                       \\ \hline
\textbf{\texttt{char}}              & \texttt{Char\_t}                     &                         & 8                   & 8                   & \texttt{signed}かどうかは環境依存 &                                                                                                                             \\ \hline
\textbf{\texttt{bool}}              & \texttt{Bool\_t}                     &                          &                     &                     & 環境依存                                              & \texttt{false}/\texttt{true}                                                                                                                  \\ \hline
\textbf{\texttt{float}}             & \texttt{Float\_t}                    & 32                       & 32                  & 32                  &                                                   & $\pm3.402,823,4\times 10^{38}$                                                                                                        \\ \hline
\textbf{\texttt{double}}            & \texttt{Double\_t}                   & 64                       & 64                  & 64                  &                                                   & $\pm1.797,693,134,862,315,7 \times 10^{308}$                                                                                           \\ \hline
\textbf{\texttt{long double}}       & \texttt{LongDouble\_t}               &                          & 80                  & 80                  &                                                   &                                                                                                                             \\ \hline
\end{tabular}
\normalsize
\end{table}
\end{landscape}

ここで注意したいのが、例えば同じ\texttt{int}を使用してコード~\ref{code:triple2}のようにプログラムを作成したとしても、使用している計算機やOSによっては扱える整数の範囲が異なる場合があることです。表~\ref{table:primitive}には64~bitのmacOSやLinuxなどの場合しか掲載していませんが、研究室にある少し古い計算機（例えば2010年頃のもの）は32~bitのOSがインストールされている場合があり、同じ\texttt{int}でも$-32768$〜$+32767$の範囲しか扱えないかもしれません。

どのような環境でも同じ計算結果をえられるようにするため\footnote{可搬性（portability）を高めると言います。}、ROOTではこれらの型に対して\texttt{Int\_t}のような新しい型を定義しています。これは\texttt{\$ROOTSYS/include/RtypesCore.h}で例えば次のように\texttt{typedef}を使用して定義されています\footnote{ROOTのライブラリを使用するとき以外は、これらROOT独自の型は使用できません。}\footnote{ROOTを使わない場合のC++でも型の可搬性を高めるために、C++11では\texttt{<cstdint>}というヘッダを用意しており、これをインクルードすることで\texttt{std::uint16\_t}や\texttt{std::int32\_t}などの型を使用できるようになります。これは環境依存がありません。}。
\begin{lstlisting}[language=c++]
#ifdef R__INT16
typedef long           Int_t;       //Signed integer 4 bytes
typedef unsigned long  UInt_t;      //Unsigned integer 4 bytes
#else
typedef int            Int_t;       //Signed integer 4 bytes (int)
typedef unsigned int   UInt_t;      //Unsigned integer 4 bytes (unsigned int)
#endif
\end{lstlisting}

C++の最初の練習には、整数値の範囲や浮動小数点（\texttt{float}、\texttt{double}、\texttt{long double}）の精度を気にする必要はありません。しかし大きな数を扱ったり、精度の必要な計算をする場合には注意が必要です。例えば次の計算をROOTでやってみると、表現できる値の範囲を超えたときに何が起きるか分かるでしょう。
\begin{lstlisting}[language=c++]
root [0] short a = 32766
(short) 32766
root [1] a += 1
(short) 32767
root [2] a += 1
(short) -32768
\end{lstlisting}
2進数で$32766$は$(0111111111111110)_2$であり、計算機上ではこれをビットの並びとして記録しています。ここに1を足すと$(0111111111111111)_2$となり、さらに1を足すと$(1000000000000000)_2$になります。C++では2進数の最大桁が0か1かによって\texttt{signed}型の正負を決定しており、さらに多くのC++コンパイラでは「2の補数表現」\footnote{詳しくは検索してください。}を使っているため、$(1000000000000000)_2=-1\times(2^{16-1})$と変換されてしまうのです。

浮動小数点の型の場合、この限られたビット数を正負符号（1ビット）、指数部（\texttt{float}の場合8ビット）、仮数部（\texttt{float}の場合23ビット）に使い分けます。そのため、表\ref{table:primitive}にある最大値のおよそ$3.4028234\times10^{38}$（10進法表記）というのは、実際には$(1.11111111111111111111111)_2\times2^{(11111111)_2}$のことです。

多くの場合、浮動小数点の見た目は10進数で書かれることが多いですが、実際にはそれに十分近い2進数の指数部と仮数部で計算機は内部表現していることに気をつけてください。例えば\texttt{float}の引き算を次のように実行した場合、得られる結果は$123.456-123.444=0.012$とは異なるものになります（丸め誤差）。

\begin{lstlisting}[language=c++]
root [0] float a = 123.456
(float) 123.456f
root [1] float b = 123.444
(float) 123.444f
root [2] a - b
(float) 0.0120010f
root [3] a - b == 0.012
(bool) false
\end{lstlisting}

\section{配列}
\label{sec:arrays}
\texttt{int}や\texttt{double}という型を使って、整数や有限桁の少数を扱うことができました。メモリの許す限り、好きなだけ変数を用意して計算をすることができます。しかし、変数が数百にもなると、もはや人力で変数を管理するのは困難です。また重複しないように変数名を考えることすらできません。そこで、関連した変数をひと塊にすることができます。それが配列（array）です。

\texttt{Vector3D}クラスの例では、$(x, y, z)$の組みをメンバ変数\texttt{fX}、\texttt{fY}、\texttt{fZ}を\texttt{double}として持ちました。しかし例えば10次元のベクトルや任意の次元のベクトルを扱いたい場合、Zの後に何を使えば良いか迷ってしまいますし、数が増えるたびに変数名を考えなくてはいけなくなります。また、内積の計算をするときも、いちいち全ての変数を書かなくてはいけなくなります。ここでは一度クラスを忘れて、次のようなベクトル$\vec{a}$と$\vec{b}$の内積を考えてみましょう。
\begin{lstlisting}[language=c++]
root [0] double a1 = 1., a2 = 2., a3 = 3., a4 = 4., a5 = 5.;
root [1] double b1 = 10., b2 = 20., b3 = 30., b4 = 40., b5 = 50.;
root [2] double ab = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4 + a5 * b5
(double) 550.00000
\end{lstlisting}
これは明らかに面倒ですし、一般化しにくくなります。そこで次のようにしてみましょう\footnote{ここでは簡単のため、要素数が\texttt{a}も\texttt{b}も確かに5個であるというチェックをしていません。}\footnote{このような配列の初期化の記法はC++11以降のものです。古いC++では、\texttt{double a[] = \{1., 2., 3., 4., 5.\}}と書きました。}。
\begin{lstlisting}[language=c++]
root [0] double a[] {1., 2., 3., 4., 5.};
root [1] double b[] {10., 20., 30., 40., 50.};
root [2] double ab = 0.;
root [3] for(int i = 0; i < 5; ++i) ab += a[i] * b[i];
root [4] ab
(double) 550.00000
\end{lstlisting}
このようにすると、要素数が増えても一般化しやすくなります。

上記の例のように、\texttt{[]}を使うことで配列の作成や初期化ができます。また各要素にアクセスしたい場合も\texttt{[]}を使うことで特定の要素を一つの変数のように扱い、そこの値を読んだり代入したりできるようになります。

注意したいのは、このように要素数が最初に決定された配列を使用する場合、後から要素数を簡単に増やすことはできません\footnote{最初からメモリ資源を考えずに十分大きな配列を確保する、\texttt{malloc}を使用して動的に配列を作成する、可変長の配列を独自に実装する、などの方法はありえます。}\footnote{これはC/C++の言語仕様であるため、どうにもできません。C++のSTLやPythonで簡単に配列を可変にできるのは、うまいことそのような機能をC言語などで実装しているからです。}。そこでC++では、標準テンプレートライブラリ（Standard Template Library、STL）のひとつとして、\texttt{std::vector}を用意しています。ここではSTLや\texttt{std::vector}の詳細には踏み込みませんが、世の中に転がっている同じようなC++の例題でも、配列を使っていたり\texttt{std::vector}を使っていたりと十人十色なことに注意してください。計算速度を重視する場合やOSの低レベルな機能を使用する場合をのぞき、最近では配列の代わりに\texttt{std::vector}を積極的に使用するのが良いと思います。

\begin{lstlisting}[language=c++]
root [0] std::vector<int> a {1, 2, 3, 4, 5}
(std::vector<int> &) { 1, 2, 3, 4, 5 }
root [1] a.push_back(6)
root [2] a
(std::vector<int> &) { 1, 2, 3, 4, 5, 6 }
root [3] a[5]
(int) 6
\end{lstlisting}

またこれはROOT固有の話になりますが、ROOTはSTLが登場する前に開発が開始されました。そのため（徐々に変わりつつありますが）ROOTの内部ではSTLが多用されておらず、\texttt{TArray}、\texttt{TObjArray}、\texttt{TList}といった独自の配列用クラスが過去のROOTとの互換性のために今でも使われています。

\section{文字列とメモリ}
節~\ref{sec:primitive}で見たように、整数型には\texttt{char}と呼ばれる型があります。これは英語のcharacterの頭を取ったものであり、主に文字または文字列を扱うときに使用します。まず文字単体を変数に代入してみましょう。
\begin{lstlisting}[language=c++]
root [0] char c = 'a'
(char) 'a'
\end{lstlisting}
このように、a という文字を変数\texttt{c}に代入するときは、その文字をシングルクオートで囲みます。\texttt{char}は文字を記憶することができる変数ですが、その内部表現は単なる整数です。そのため例えばこれを\texttt{int}型の変数に代入すると、a は97という数字に対応していることがわかります。
\begin{lstlisting}[language=c++]
root [1] int C = c
(int) 97
\end{lstlisting}

数字の97（より正確には2進数の$(01100001)_2$）はあくまで数字です。これをターミナルの画面でアルファベットとして表示するのは、単にターミナルやOSがうまいこと人間に合わせて動作してくれているからです。例えば「ABC」とだけ記入されたテキストファイルがあれば、それはビット列として\texttt{010000010100001001000011}という情報\footnote{実際にこのような順序でメモリ上に並んでいるかは、使っているCPUなどの環境に依存します。}が記録されただけのファイルであり、拡張子が\texttt{.txt}だからというような理由で、ソフトウェアが文字情報としてうまいこと表示してくれているのです。

さて、単一の文字ではなく、文字列を保持したい場合には\texttt{char}型の配列を使用すれば良いことが想像できます。しかし、例えばHelloという言葉を配列を使って次のように初期化するのは面倒です。
\begin{lstlisting}[language=c++]
root [0] char str[] {'H', 'e', 'l', 'l', 'o', '\0'}
(char [6]) "Hello"
\end{lstlisting}
これを簡単に初期化するため、C++では次のような記法が許されています。
\begin{lstlisting}[language=c++]
root [0] char str[] {"Hello"} // str[] = "Hello" でも可
(char [6]) "Hello"
\end{lstlisting}

ここで最初の例では、Helloは5文字しかないのに最終要素に\texttt{\textbackslash{}0}という文字を追加して、6要素を持つ配列を確保しています。この\texttt{\textbackslash{}0}は終端文字（ヌル文字、null character）と呼ばれ、文字列の終わりであることを計算機に知らせる役割を果たしており\footnote{\texttt{\textbackslash{}0}のようにバックスラッシュをつけて入力する文字を特殊文字とかエスケープシーケンス（escape sequence）と呼びます。英数字のみで表せない文字です。他には改行のための文字である\texttt{\textbackslash{}n}や、タブ\texttt{\textbackslash{}t}などがあります。}、数値としてもゼロになっています。そのため、もし4要素目にこの終端文字を代入してしまうと、C++は\texttt{str}の中身を\texttt{Hell\textbackslash{}0o}ではなく\texttt{Hell}だと認識するようになります。
\begin{lstlisting}[language=c++]
root [1] str[4] = '\0'
(char) '0x00'
root [2] str
(char [6]) "Hell"
\end{lstlisting}

なぜこのように\texttt{\textbackslash{}0}を使用する必要があるのか、どうして5文字使うだけなのに余計な1文字を消費するのかと疑問に思うかもしれません。その理由は、CやC++では任意の配列の長さを調べることができない、言い換えると、配列自身は配列長という情報を持っていないという言語仕様のためです\footnote{「任意の」と書いたのは、プログラムの場所によっては\texttt{sizeof(str)}とすることで配列長を取得できる場合があるからです。これはコンパイラ（もしくはROOT）がコンパイル時に\texttt{str}の初期化で使われた文字数を数えてくれるからです。プログラムの全ての場所で\texttt{sizeof}が有効に使えるというわけではありません。}。少し詳しく解説してみます。

上記の例で\texttt{str[]}という配列がメモリ上に確保された場合、その初期化に必要な大きさのメモリ領域がOSによって占有されます。\texttt{char}は1バイト（8ビット）の大きさなので、合計6文字分、つまり6バイトのメモリ領域が連続的に使用されます。あるプログラムがメモリの読み書きをする場合、当然ですがメモリのどの領域を読み書きするのかを知っていなくてはいけず、その情報をOSと共有している必要があります。そのメモリの場所のことをアドレス（address）と呼びます。

メモリのアドレスは、多くの場合16進数で表示します\footnote{16進数は0〜9の10個の数字に加え、a〜f（もしくはA〜F）の6文字を数字の代わりに使用します。$(12)_{10}$は$(\mathrm{c})_{16}$と、$(4095)_{10}$は$(\mathrm{fff})_{16}$と同じになります。16進数をC++などのコード中で表記するときは、$(\mathrm{fff})_{16}$を\texttt{0xfff}や\texttt{0xFFF}のように書きます。2桁で$2^{8}$相当の情報を持つことができるため、これが1バイトに相当します。}。例えば次の例では、\texttt{0x1119c0658}〜\texttt{0x1119c065d}（$(1119\mathrm{c}0658)_{16}$〜$(\mathrm{1119c065d})_{16}$）のアドレス範囲にあるメモリが\texttt{str[]}配列に使用されており、その1バイトずつに\texttt{char}が1文字ずつ数値として記録されています。この例ではアドレスの最小桁が8からdへと1ずつ増えている（1バイトずつ移動している）ことに注意してください。

\begin{lstlisting}[language=,basicstyle={\scriptsize\ttfamily},keywordstyle=,stringstyle=,ndkeywordstyle=,identifierstyle=]
-------------------------------------------------------------------------------------
| 0x1119c0658 | 0x1119c0659 | 0x1119c065a | 0x1119c065b | 0x1119c065c | 0x1119c065d | メモリ上のアドレス ...(A)
-------------------------------------------------------------------------------------
|   Byte 0    |    Byte 1   |    Byte 2   |    Byte 3   |    Byte 4   |    Byte 5   | バイト列として数えた順番
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
|    0x48     |     0x65    |     0x6c    |     0x6c    |     0x6f    |     0x00    | バイト列の値 ...(B)
-------------------------------------------------------------------------------------
|     H       |      e      |      l      |      l      |      o      |      \0     | 文字として表示した場合の中身
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
|   str       |   str + 1   |   str + 2   |   str + 3   |   str + 4   |   str + 5   | (A) の値を取り出す方法
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
|   str[0]    |    str[1]   |    str[2]   |    str[3]   |    str[4]   |    str[5]   | (B) の値を取り出す方法その1
-------------------------------------------------------------------------------------
|   *str      |  *(str + 1) |  *(str + 2) |  *(str + 3) |  *(str + 4) |  *(str + 5) | (B) の値を取り出す方法その2
-------------------------------------------------------------------------------------
\end{lstlisting}

\texttt{char[] str \{"Hello"\}}でC++が行う作業は、メモリの確保とその初期化です。6バイト分のメモリを確保したのち、そのひとつずつに\texttt{0x48}や\texttt{0x65}という値を書き込んでいきます。つまり、メモリアドレス\texttt{0x1119c065c}には値\texttt{0x6f}が書き込まれているということです。

節~\ref{sec:primitive}では「型」の概念を学びました。それでは、ここで使われている変数\texttt{str}の型はなんでしょうか。\texttt{char}型でしょうか、\texttt{char}型の配列という型でしょうか。C++では配列という表現があるものの、配列という型は存在せず、配列の実体は上述のように単にアドレスの連続したメモリ領域のことです。そのため「\texttt{char}型の配列という型」のようなものは存在しません。実は\texttt{str}は「\texttt{char}のポインタ型」（\texttt{char*}と表記）と呼ばれる型の変数です。

\texttt{char*}型の変数は、その値に\texttt{H}（\texttt{0x48}）などを保持しているわけではなく、アドレスを保持しています。メモリ空間のアドレスを指し示す役割を果たすため、ポインタ（pointer）と呼ばれます。ROOTのプロンプトはユーザの利便性のため「親切に」\texttt{char*}型の変数を文字列として表示するので、次の例で示すやり方で\texttt{str}の値を表示してみましょう。\texttt{0x1119c0658}という値を持っていることが分かります\footnote{\texttt{(void*)}を付加することで、\texttt{str}の型を\texttt{char*}から\texttt{void*}へキャスト（cast、異なる型へ変換すること）しています。違うポインタ型にすることで、「親切に」ROOTが文字列を表示しないようにしています。}。

\begin{lstlisting}[language=c++]
root [3] str // これだと ROOT がポインタの値を表示してくれない
(char [6]) "Hello"
root [4] printf("%p\n", str); // 16 進数を文字列として表示
0x1119c0658
root [5] (void*)str // キャストする
(void *) 0x1119c0658
\end{lstlisting}

配列では次のようにして配列の要素を取り出すことができました。しかしこれは、\texttt{str}が\texttt{char*}型であることを踏まえると一体何をやっているのでしょうか。
\begin{lstlisting}[language=c++]
root [6] str[0]
(char) 'H'
\end{lstlisting}
実はこの操作は、次のよくわからない記法を分かりやすくした全く同一の操作なのです\footnote{このような難しい表現を簡単な表現にして同一の操作を実現する構文を、糖衣構文（シンタックスシュガー、syntax sugar）と言います。}。
\begin{lstlisting}[language=c++]
root [7] *str
(char) 'H'
\end{lstlisting}
ポインタ型の変数はメモリ上のアドレスを保持する役割をもちますが、その変数に\texttt{*}をつけると、そのアドレスに書き込まれた値を取り出すことができます。また例えば\texttt{str + 2}は\texttt{str}の指すアドレスの2つ先なので\texttt{0x1119c065a}を指しますが、\texttt{*}をつけるとそのアドレスに書き込まれた値を取り出すことができるので、次のような操作が行ええます。
\begin{lstlisting}[language=c++]
root [8] str[2]
(char) 'l'
root [9] *(str + 2)
(char) 'l'
\end{lstlisting}
このように考えたとき、計算機側からは\text{char*}型の\texttt{str}を見ただけでは、それが何バイト分だけ文字列として有効かを知る術がありません。例えば次のように「勝手に」6文字を超えてメモリ上の値にアクセスしてみましょう。メモリ上には他の変数が書き込まれていたり、以前に書き込まれていた値が残っていたりします。そのため、確保した覚えのないメモリ領域から何かしらの値が取得できてしまう場合があるのです\footnote{プログラムをクラッシュさせる場合もあります。}。

\begin{lstlisting}[language=c++]
root [10] *(str + 10)
(char) '0x7f'
root [11] *(str + 100)
(char) '0x86'
\end{lstlisting}

さて、なぜ\texttt{\textbackslash{}0}が必要なのかという問いにようやく戻ると、どこまでが文字列として使用しているメモリ領域かを計算機に伝える目印が必要だからです。CやC++の文字列では\texttt{\textbackslash{}0}が現れる直前の文字をその文字列の最後尾とみなし、\texttt{\textbackslash{}0}によって文字列の終端を示すのです。

さらに、もう少し複雑なメモリへのアクセスを試すことで、この節での説明を理解できているか確認してみましょう。次の例のように、まず\texttt{str + 1}のアドレスを\texttt{short*}（\texttt{short}のポインタ型）でキャストします。このとき変数\texttt{sp}はアドレス\texttt{0x1119c0659}を指すようになり、またその領域に書き込まれている値は\texttt{short}型であると思い込むようになります。そこで、\texttt{*sp}としてそのアドレスに書き込まれた\texttt{short}の値を取り出すと、16進数で0x6c65（10進数で27749）になります\footnote{この値が\texttt{0x6c65}になるか\texttt{0x656c}になるかは使用している計算機やCPUの種類によります。詳しくは「エンディアン」で検索してみてください。}。

\begin{lstlisting}[language=c++]
root [12] short* sp = (short*)(str + 1)
(short *) 0x1119c0659
root [13] *sp
(short) 27749
root [14] 0x6c65
(int) 27749
\end{lstlisting}

注意したいのが、2バイト以上のメモリを使用する型のポインタを増減させる場合です。\texttt{sp}は\texttt{short*}型なので\texttt{sp + 1}は\texttt{sp}から1バイトだけ増えるような気がします。しかし\texttt{sp + 1}が示すのは\texttt{0x1119c065a}というアドレスではなく、\texttt{0x1119c065b}です。
\begin{lstlisting}[language=c++]
root [15] sp + 1
(short *) 0x1119c065b
root [16] *(sp + 1)
(short) 28524
\end{lstlisting}
これは\texttt{short*}型にとって1増えるというのは、\texttt{short}のメモリの大きさの分だけ（2バイト分だけ）アドレスを移動するという意味だからです。

また、同じ1バイトの整数型であっても、\texttt{signed}か\texttt{unsigned}かによって計算に使用される数値としては別物だということにも注意しましょう。次の例の場合、メモリに書き込まれている値はどちらも\texttt{0xff}です。
\begin{lstlisting}[language=c++]
root [0] signed char a = 0xff
(signed char) '0xff'
root [1] unsigned char b = 0xff
(unsigned char) '0xff'
root [2] printf("%d %d\n", a, b)
-1 255
(int) 7
\end{lstlisting}


さて、ここまで文字列を例にとって配列とポインタのややこしい関係を説明してきました。しかし、より現代的なC++プログラミングでは文字列にSTLの\texttt{std::string}型を使うことが多くあります。
\begin{lstlisting}[language=c++]
root [17] std::string s {"Hello"}
(std::string &) "Hello"
\end{lstlisting}

\section{スコープ}
\label{sec:scope}

ここまで扱ってきたいくつかの型による変数には寿命が存在します。変数を宣言するとその型や配列長に応じてメモリが確保され、そのメモリ領域が不要になった際にユーザもしくはOSがその領域を解放します（他のプログラムが利用できるようになります）。通常の変数はあるブロック内\footnote{\texttt{\{\}}で囲まれた領域。}で宣言されたときに始まり、そのブロックを抜けるときに終了します。これを変数のスコープ（scope）と呼びます。
\begin{lstlisting}[language=c++]
{
  int a = 0;
}
a += 1; // a が宣言されたブロックを既に抜けているので無効
\end{lstlisting}

\begin{lstlisting}[language=c++]
for (int i = 0; i < 10; ++i) {
  // 何か処理
}
std::cout << i << std::endl; // i が for ブロックを既に抜けているので無効
\end{lstlisting}

\begin{lstlisting}[language=c++]
void func() {
  int a = 0;
}

int main() {
  func();
  std::cout << a << std::endl; // func の中で宣言された変数なので無効
  return 0;
}
\end{lstlisting}

また、既に存在している変数名が新たなブロック内で宣言されると、新たな変数がそのブロック内では有効になります。

\begin{lstlisting}[language=c++]
int a = 1;
if (a == 1) {
  int a = 2; // 新しい変数
  std::cout << a << std::endl; // 新しい変数の中身 2
}
std::cout << a << std::endl; // 最初の変数の中身のまま 1
\end{lstlisting}

一般的にC++のプログラミングでは、使用する変数のスコープをできる限り小さくするのが鉄則です。例えば変数\texttt{a}と\texttt{b}の値を入れ替えたい場合は一時的な変数を用意する必要がありますが、この変数は後で使い回すわけではないので、スコープを短くしておいたほうがそのプログラムの「読者」（共同研究者かもしれませんし、数週間後のあなた自身かもしれません）が変数の役割を理解しやすくなります。
\begin{lstlisting}[language=c++]
int a = 1, b = 2;
{
  int tmp = a;
  a = b;
  b = tmp;
}
\end{lstlisting}
\texttt{for}文を回すときに変数\texttt{i}を\texttt{for}と同じ行で宣言するのも、\texttt{i}を\texttt{for}文の外では使用しないことを明らかにできます。

\begin{NoFloat}
\lstinputlisting[language=c++,caption=\texttt{first\_script4.C},label=code:first_script4_C,numbers=left]{src/first_script4.C}
\end{NoFloat}

この変数の寿命がスコープ内にとどまるというC++の機能は、もう使用しないメモリを解放したり、可読性の高いコードを書くという観点からは大変便利なものです。しかしROOTではこの機能が邪魔になる場合があります。まず最初にコード~\ref{code:first_script4_C}を見てみましょう。これはコード~\ref{code:first_script}を少し改変したもので、\texttt{TH1D}型の変数\texttt{hist}を作り、正規分布で乱数を詰めた後に\texttt{Draw}しています。これを試しに実行してみてください。

\begin{lstlisting}[language=c++]
root [0] .x first_script4.C
Info in <TCanvas::MakeDefCanvas>:  created default TCanvas with name c1
root [1] gDirectory->ls()
\end{lstlisting}

実行自体は問題なくでき、\texttt{hist}を\texttt{Draw}する際に必要となる\texttt{TCanvas}の自動生成も行われています。しかし画面に現れる\texttt{c1}は真っ白のはずです。また\texttt{myhist}という名前で生成したはずの\texttt{TH1D}も、\texttt{gDirectory->ls()}で表示されません。

これは\texttt{hist}のスコープが関数\texttt{first\textbackslash{}script4}を抜けると同時に終了し、\texttt{hist}がメモリ上から消去されてしまうためです。ROOTの解析では関数を抜けた後に引き続きその変数（classの場合インスタンスもしくはオブジェクトとも呼ぶ）を表示したり追解析したいことが頻繁にあるため、このようにメモリ上から消されてしまっては困ってしまいます。これを回避するのが、コード~\ref{code:first_script}で使われていた\texttt{new}です。

\section{\texttt{new}と\texttt{delete}}
\label{sec:new_delete}

通常の変数では、例えば\texttt{int a = 1;}のようにメモリが確保される場合、このメモリ領域は「静的に」（statical）確保されます。静的に確保されるとは、そのコードのコンパイル時に使用するメモリの量が決定していて、プログラムを実行するとそれに応じてメモリ使用量が変化しないということです。一方、使用するメモリ量がプログラム作成時には決定していないような場合も存在します。例えば陽子・陽子の衝突で生じた複数の中間子の運動量を\texttt{double}の配列に記録したいとします。このとき何個の中間子が出てくるかは衝突事象ごとに異なりますので、必要となるメモリ量を事前に決定することができません。このような場合、メモリを「動的に」（dynamical）に確保する必要があります\footnote{あくまで例なので、実際にはこのようなコードは書かないと思います。}。

新しく変数やオブジェクトを作成する場合に\texttt{new}を使用すると、必要なメモリ領域が動的に確保されます。陽子・陽子衝突の例で$n$個の中間子が生成されたとして、その運動量を記録するために合計$4n$個の\texttt{double}を確保しようとすると、次のようにします。
\begin{lstlisting}[language=c++]
root [0] int n = 10
(int) 10
root [1] double* p = new double[4 * n]
(double *) 0x7fc9968e9cc0
\end{lstlisting}
\texttt{new}演算子はその右側にある型の必要バイト数に応じて、また配列の場合はその配列長の分だけメモリ領域を動的に確保します。この場合、\texttt{double}は8バイト使用するので、合計$32n$バイトのメモリ領域を確保します。\texttt{new}演算子は確保されたメモリ領域の先頭アドレスを返します。したがって\texttt{char}配列と文字列を学んだときのように、\texttt{[]}を使用してその配列の値を次のように読み書きすることができます。
\begin{lstlisting}[language=c++]
root [2] std::cout << p[3] << std::endl;
2.5526e+151
root [3] p[3] = 1.2345
(double) 1.2345000
root [4] std::cout << p[3] << std::endl;
1.2345
\end{lstlisting}
ここで注意したいのが、\texttt{new}で確保された領域は初期化されず、\texttt{double}の値がデフォルト値であるゼロになりません。この例で初期値が\texttt{2.5526e+151}になっているのは、そのメモリ領域に残っていた以前の情報（ビット列）を\texttt{double}に変換してしまっているためです。

動的に確保されたメモリを解放するのはユーザの責任です。次のように\texttt{delete []}を使って配列を消去します。
\begin{lstlisting}[language=c++]
root [5] delete [] p
root [6] p = 0
(double *) nullptr
\end{lstlisting}
最後に\texttt{0}を代入するのは、ポインタ\texttt{p}が意味のないアドレス（そこに確保した配列が既に存在していないアドレス）を保持し続けるのを回避するためです。

ここまでくると、なぜコード~\ref{code:first_script}だと図が表示され、コード~\ref{code:first_script4_C}だと図が消えてしまうのか理解できたと思います。\texttt{new}で動的に確保された\texttt{TH1D}のメモリは、スコープを外れても自動で消去されません。ただし、\texttt{TH1D*}型の\texttt{hist}という変数自体は消去されてしまいます。これはそのヒストグラムの存在するメモリの先頭アドレスを指すポインタ変数が消えるだけで、メモリ上の情報自体は消去されないということに注意してください。

\section{ポインタと参照}
\label{sec:pointers}

\section{\texttt{virtual}}
\label{subsec:virtual}


\section{プログラムの書き方}
